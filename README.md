Лабораторная работа №3
"Подсистема прерываний"

К теме: Организация подсистемы прерываний. Контроллер прерываний.

ЦЕЛЬ РАБОТЫ
Изучить организацию прерываний в IBM PC с использованием контроллера прерываний.
Продолжительность работы - 4 часа.

ЗАДАНИЕ
Под MS DOS написать программу, которая:
1) выполняет инициализацию контроллера прерываний;
2) выводит на экран содержимое регистров запросов, обслуживаний и масок для ведущего и ведомого контроллеров (через видеобуфер).
*При нажатии на клавиши меняется цвет или фон выводимой информации.
Программа должна быть резидентной. Все векторы прерываний переопределяются, новый базовый адрес выбирается в соответствии с вариантом.

ТЕОРЕТИЧЕСКИЕ СВЕДЕНИЯ
Каждый момент времени центральный процессор может работать только с одним устройством. Циклический опрос каждого устройства с последующей обработкой запроса оказался неэффективным. Решение задачи оказался контроллер прерываний, который принимает запросы от устройств и в соответствии с приоритетом направляет их процессору, если прерывание от данного устройства не замаскировано (разрешено) в регистре масок. Если прерывание разрешено и устройство его запросило, то устанавливается соответствующий устройству бит в регистре запросов.
Контроллер прерываний состоит из двух микросхем, подключенных каскадно (ведущий и ведомый контроллеры), каждая из которых имеет по 8 линий прерываний (IRQ0-IRQ7, IRQ8-IRQ15). За каждой линией закреплено определенное устройство.
Когда процессор получает запрос на прерывание,  он сохраняет свое текущее состояние и переключается на выполнение запрошенной операции. При этом устанавливается бит в регистре обслуживания (бит запроса сбрасывается). После обслуживания прерываний сбрасывается бит обслуживания, посылается сигнал EOI (end of interrupt), процессор переключается на выполняемую ранее задачу.
Для доступа к контроллеру прерываний используются порты 20h и 21h (для ведущего), A0 иA1h (для ведомого).
Регистр масок доступен через порт 21h /A1h. Чтобы изменить определенный бит, нужно считать значение из этого регистра, изменить нужный бит, записать значение обратно.
Чтобы считать регистр запросов, его нужно выбрать (записать в 20h/A0h значение 0Ah), а затем считать содержимое из порта 20h/A0h.
Чтобы считать регистр обслуживания, его нужно выбрать (записать в 20h/A0h значение 0Bh), а затем считать содержимое из порта 20h/A0h.
Для резидентной программы понадобится следующий фрагмент кода:
unsigned far *fp;     //объявляем указатель
FP_SEG (fp) = _psp; // получаем сегмент
FP_OFF (fp) = 0x2c; // и смещение сегмента данных с переменными среды
_dos_freemem(*fp); //чтобы его освободить

_dos_keep(0,(_DS -_CS)+(_SP/16)+1);//оставляем резидентной, указывая 							 //первым параметром код завершения, а 							//вторым - объем памяти, который должен 						//быть зарезервирован для программы 							//после ее завершения
